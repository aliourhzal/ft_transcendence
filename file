// @SubscribeMessage('join-room') 
    // @UsePipes(new ValidationPipe()) // Add the ValidationPipe here
    // async joinRoom(@MessageBody() dto:JoinRoomDto , @ConnectedSocket() socket: Socket) 
    // {
        
    //     try 
    //     {
    //         const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);

    //         if (token) 
    //         {
    //             const user  = await this.utils.verifyToken(token); // if has error will catch it
                
    //             const rtn = await this.utilsFunction(socket , user , dto.roomName , null , 1);
                
    //             if(rtn.error)
    //             {
    //                 console.log(rtn.error)
    //                 return ;
    //             }
    //             else
    //             {
    //                 if(rtn.room.roomType !== 'PRIVATE')
    //                 {
    //                     const usersInRoom:any = await this.utils.getUsersInRooms(rtn.room.id);
                
    //                     const find = usersInRoom.find((item:any) => item.userId === user['sub']); // search in room if user who want to join this room it is into it or not
                      
    //                     if(!find)
    //                     {
    //                         if(rtn.room.roomType === 'PROTECTED')
    //                         {
    //                             if(comparePasswd(dto.password,rtn.room.password) )
    //                             {
    //                                 const newUserAdded = await this.roomService.linkBetweenUsersAndRooms(rtn.room.id, [user['sub']]);
                                
    //                                 const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                                    
    //                                 for(const userInRoom of usersInroom)
    //                                 {
    //                                     for (let i = 0; i < this.soketsId.length; i++) 
    //                                     {
    //                                         if(this.soketsId[i].userId === userInRoom.userId)
    //                                         {
    //                                             this.server.to(this.soketsId[i].socketIds).emit('users-join', {room : rtn.room , userInfos: await this.utils.getUserInfosInRoom(rtn.room.id) , newUserAdded :[newUserAdded] });                                  
    //                                         }
    //                                     }
 
    //                                 }
    //                                 return ;
    //                             }
    //                             else
    //                             {
    //                                 console.log("password inccorect.")
    //                                 // socket.emit('users-join',"password inccorect.")
    //                                 return ;
    //                             }
    //                         }
    //                         else if(rtn.room.roomType === 'PUBLIC')
    //                         {
    //                             const newUserAdded = await this.roomService.linkBetweenUsersAndRooms(rtn.room.id, [user['sub']]);
                                
    //                             const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                                
    //                             for(const userInRoom of usersInroom)
    //                             {
    //                                 for (let i = 0; i < this.soketsId.length; i++) 
    //                                 {
    //                                     if(this.soketsId[i].userId === userInRoom.userId)
    //                                     {
    //                                         this.server.to(this.soketsId[i].socketIds).emit('users-join', {roomId : rtn.room , userInfos: await this.utils.getUserInfosInRoom(rtn.room.id) , newUserAdded  });
    //                                     }
    //                                 }
        
    //                             } 
    //                         } 
                    
    //                     }
    //                     else 
    //                     {
    //                         console.log('user aleredy in this room.')
    //                         // socket.emit('error-joinned-room','user aleredy in this room.')
    //                     }
    //                 }
    //             }
    //         } 
    //         else
    //         {
    //             console.log('invalid jwt.');
    //         }
    //     }   
    //     catch (error) 
    //     {
    //         console.log(error)
    //     }
     
        
    // }


    // @SubscribeMessage('user-promotion') // check if user is muted
    // @UsePipes(new ValidationPipe()) 
    // async UserPromotion(@MessageBody() dto:SetOtherAasAdministrators , @ConnectedSocket() socket: Socket) 
    // { 
    //     try 
    //     {
    //         const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);

    //         if (token) 
    //         {
    //             const user  = await this.utils.verifyToken(token); // // if has error will catch it
    //             const rtn = await this.utilsFunction(socket , user , dto.roomName , dto.newAdminId);
                
    //             if(rtn.error)
    //             {
    //                 console.log(rtn.error)
    //                 return ;
    //             }
    //             else
    //             {
    //                 if(rtn.usersType.usersType[0].userType === 'OWNER') // if current user is  owner in this case can set admins
    //                 { 
                     
    //                     // here before set admin check if it is aleredy admin or an  user
    //                     const result = await this.roomService.setNewAdmins(rtn.room.id, rtn.usersType.usersType[1]);

    //                     if(result.error)
    //                     {
    //                         console.log(result.error);
    //                         return ;
    //                     }
    //                     else
    //                     {
                            
    //                         const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
    //                         for(const userInRoom of usersInroom)
    //                         {
    //                             for (let i = 0; i < this.soketsId.length; i++) 
    //                             {
    //                                 if(this.soketsId[i].userId === userInRoom.userId)
    //                                 {
    //                                     this.server.to(this.soketsId[i].socketIds).emit("onPromote",{ roomId: rtn.room ,  newAdmin: result.updatesUserType });
    //                                 } 
    //                             }
    //                         }
    //                     }
    //                 }  
    //                 else
    //                 {
    //                     console.log('dont have the permission to set an admin.');
    //                     return ;
    //                 }
                    
    //             }
    //         } 
    //         else
    //         {
    //             console.log('invalid jwt.');
    //         }
    //     }   
    //     catch (error) 
    //     {
    //         console.log(error)
    //     }

        
    // }

    // /*
    //     * before demte admin
    //     - check if both user is exist
    //     - check room if exsit
    //     - check if both user in same room 
    //     - if is banned
    //     - check if current user is owner
    //     - check if who want to be domted is admin
    //     - if aleredy admin
    // */
    // @SubscribeMessage('user-demote') 
    // @UsePipes(new ValidationPipe()) 
    // async DemoteAdmin(@MessageBody() dto:DemoteUser , @ConnectedSocket() socket: Socket) 
    // {
    //     try 
    //     {
    //         const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);

    //         if (token) 
    //         {
    //             const user  = await this.utils.verifyToken(token); // // if has error will catch it
    //             const rtn = await this.utilsFunction(socket , user , dto.roomName , dto.dmotedUserId);
                
    //             if(rtn.error)
    //             {
    //                 console.log(rtn.error)
    //                 return ;
    //             }
    //             else
    //             {
                    
    //                 if(rtn.usersType.usersType[0].userType === 'OWNER') // if current user is  owner in this case can set admins
    //                 { 
    //                     if(rtn.usersType.usersType[1].userType === 'USER')
    //                     {
    //                         console.log('you are not admin.');
    //                         return ;
    //                     }
    //                     const result = await this.roomService.changeToUser(rtn.room.id, rtn.usersType.usersType[1].userId);
                        
    //                     const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                        
    //                     for(const userInRoom of usersInroom)
    //                     {
    //                         for (let i = 0; i < this.soketsId.length; i++) 
    //                         {
    //                             if(this.soketsId[i].userId === userInRoom.userId)
    //                             {
    //                                 this.server.to(this.soketsId[i].socketIds).emit("onDemote",{ roomId : rtn.room ,  domotedAdmin: result.updatesUserType });
    //                             } 
    //                         }
    //                     }                        
    //                 }
    //                 else
    //                 {
    //                     console.log('dont have the permission to set an admin.');
    //                     return ;
    //                 }
    //             }
    //         } 
    //         else
    //         {
    //             console.log('invalid jwt.');
    //         }
    //     }   
    //     catch (error) 
    //     {
    //         console.log(error)
    //     }
    // }


    //  /*
    //     * before kick
    //     - check if both user is exist
    //     - check room if exsit
    //     - check if both user in same room 
    //     - if is banned
    //     - check if current user is owner or admin
    //     - check if who want to be kick is not the owner
    // */

    //     @SubscribeMessage('kick-user') 
    //     @UsePipes(new ValidationPipe()) 
    //     async KcickUser(@MessageBody() dto:KickUser , @ConnectedSocket() socket: Socket) 
    //     {

    //         try 
    //         {
    //             const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);

    //             if (token) 
    //             {
    //                 const user  = await this.utils.verifyToken(token); // // if has error will catch it
    //                 const rtn = await this.utilsFunction(socket , user , dto.roomName , dto.kickedUserId);
                    
    //                 if(rtn.error)
    //                 {
    //                     console.log(rtn.error)
    //                     return ;
    //                 }
    //                 else
    //                 {
                        
    //                     if(rtn.usersType.usersType[0].userType !== 'USER' && rtn.usersType.usersType[1].userType !== 'OWNER') 
    //                     {
    //                         const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                            
    //                         const result = await this.roomService.removeUserFromRoom(rtn.room.id, rtn.usersType.usersType[1].userId);

    //                         for(const userInRoom of usersInroom)
    //                         {
                             
    //                             for (let i = 0; i < this.soketsId.length; i++) 
    //                             {
    //                                 if(this.soketsId[i].userId === userInRoom.userId)
    //                                 {
    //                                     this.server.to(this.soketsId[i].socketIds).emit("onKick",{ roomId: rtn.room ,  kickedUser: result.kickedUser });
    //                                 } 
    //                             }
    //                         }

    //                         console.log('user kcicked succsufully')
    //                     }  
    //                     else
    //                     {
    //                         console.log('dont have the permission to set an admin.');
    //                         return ;
    //                     }
                        
    //                 }
    //             } 
    //             else
    //             {
    //                 console.log('invalid jwt.');
    //             }
    //         }   
    //         catch (error) 
    //         {
    //             console.log(error)
    //         } 
    //     }


    //     @SubscribeMessage('add-room-users') 
    //     @UsePipes(new ValidationPipe()) 
    //     async addNewUsersToRoom(@MessageBody() dto:AddNewUsersToRoom , @ConnectedSocket() socket: Socket) 
    //     {
            
    //         try 
    //         {
    //             const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);
                
    //             if (token) 
    //             {
    //                 const user  = await this.utils.verifyToken(token); // // if has error will catch it

    //                 const usersId = await this.utils.getUsersIdByNickname(user['sub'] , dto.users , 1);
                    
    //                 if(usersId.error)
    //                 {
    //                     console.log(usersId.error);
    //                     return ;
    //                 }
    //                 const roomId = await this.utils.getRoomByName(dto.roomName);
                   
    //                 if(roomId)
    //                 {
    //                     const userType = await this.utils.getUserType(roomId.id, [user['sub']]);

    //                     if(userType.error)
    //                     {
    //                         console.log(userType.error);
    //                         return ;
    //                     }
                         
    //                     // check her if banned , if it is banned set it not banned and join it to room

                        
    //                     if(userType.usersType[0] !== 'USER') // test one by one
    //                     {
    //                         for(const userId of usersId.uniqUsers)  
    //                         {
    //                             const isBanned = await this.utils.ifUserIsBanned(userId , roomId.id);
    
    //                             if(isBanned) // if is banned make it not banned
    //                             {
    //                                 await this.roomService.makeUserUnbanned(isBanned.userId, roomId.id);
    //                             }
    //                         }                      
                            
    //                         const newUsers = await this.roomService.linkBetweenUsersAndRooms(roomId.id, usersId.uniqUsers);
                            
    //                         const usersInroom = await this.utils.getUsersInRooms(roomId.id);
                                
    //                         for(const userInRoom of usersInroom)
    //                         {
    //                             for (let i = 0; i < this.soketsId.length; i++) 
    //                             {
    //                                 if(this.soketsId[i].userId === userInRoom.userId)
    //                                 {
    //                                     this.server.to(this.soketsId[i].socketIds).emit('users-join', {roomId  , userInfos: await this.utils.getUserInfosInRoom(roomId.id) , newUserAdded : newUsers });
    //                                 }
    //                             }
    
    //                         } 
                            
    //                     }
    //                     else
    //                     {
    //                         console.log('dont have the permmission to add users to this room.')
    //                         return ;
    //                     }
    //                 }
    //                 else
    //                 {
    //                     console.log('room not found')
    //                     return;
    //                 }
                    
    //             } 
    //             else
    //             {
    //                 console.log('invalid jwt.');
    //             }
    //         }   
    //         catch (error) 
    //         {
    //             console.log(error)
    //         } 
    //     }




    //      /**
    // //      * before rename the room:
    // //      *  - check the user if is valid
    // // - if current user in this room
    // //      *  - if room is exist
    // //      *  - if new name of the room not found in db
    // //      * - if admin or owner 
    // //      */
    //     @SubscribeMessage('edit-room-name') 
    //     @UsePipes(new ValidationPipe()) 
    //     async renameRoom(@MessageBody() dto:RenameRoom , @ConnectedSocket() socket: Socket) 
    //     {
    //         try 
    //         {
    //             const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);
                
    //             if (token) 
    //             {
    //                 const user  = await this.utils.verifyToken(token); // // if has error will catch it

    //                 const existingUser = await this.utils.getUserId([user['sub']]);
                     
    //                 if(existingUser.error)
    //                 {
    //                     console.log(existingUser.error);
    //                     return ;
    //                 }

    //                 const roomId = await this.utils.getRoomByName(dto.roomName);

    //                 if(roomId)
    //                 {
    //                     const userType = await this.utils.getUserType(roomId.id,[user['sub']]);
    //                     if(userType.error)
    //                     {
    //                         console.log(userType.error);
    //                         return ;
    //                     }
    //                     if (userType.usersType[0].userType !== 'USER') 
    //                     {
    //                         if(!await this.utils.getRoomIdByName(dto.newName))
    //                         {
    //                             const oldRoomName = dto.roomName;
    //                             const newRoomName = await this.roomService.updateRoomName(roomId.id, dto.newName);

    //                             const usersInroom = await this.utils.getUsersInRooms(roomId.id);

    //                             for(const userInRoom of usersInroom)
    //                             {
    //                                 for (let i = 0; i < this.soketsId.length; i++) 
    //                                 {
    //                                     if(this.soketsId[i].userId === userInRoom.userId)
    //                                     {
    //                                         this.server.to(this.soketsId[i].socketIds).emit("change-room-name",{ oldRoomName, newRoomName : newRoomName.room_name});
    //                                     } 
    //                                 }
    //                             }

    //                         }
    //                         else
    //                         {
    //                             console.log('name of room aleredy exist');
    //                         }
    //                     }
    //                     else
    //                     {
    //                         console.log("cannot have the permission to change room Type.")
    //                     }   
    //                 }
    //                 else
    //                 {
    //                     console.log('room not found')
    //                     return;
    //                 }
                    
    //             } 
    //             else
    //             {
    //                 console.log('invalid jwt.');
    //             }
    //         }   
    //         catch (error) 
    //         {
               
    //             console.log(error)
    //         } 
    //     }



    //     @SubscribeMessage('edit-room-password') 
    //     @UsePipes(new ValidationPipe()) 
    //     async changeRoomPassword(@MessageBody() dto:ChangeRoomPassword , @ConnectedSocket() socket: Socket) 
    //     {
    //         try 
    //         {
    //             const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);
                
    //             if (token) 
    //             {
    //                 const user  = await this.utils.verifyToken(token); // // if has error will catch it

    //                 const existingUser = await this.utils.getUserId([user['sub']]);
                     
    //                 if(existingUser.error)
    //                 {
    //                     console.log(existingUser.error);
    //                     return ;
    //                 }

    //                 const roomId = await this.utils.getRoomByName(dto.roomName);

    //                 if(roomId)
    //                 {
    //                     const userType = await this.utils.getUserType(roomId.id,[user['sub']]);

    //                     if(userType.error)
    //                     {
    //                         console.log(userType.error);
    //                         return ;
    //                     }
    //                     if (userType.usersType[0].userType !== 'USER') 
    //                     {
    //                         if(roomId.roomType === 'PROTECTED')
    //                         {
    //                             await this.roomService.changePasswordOfProtectedRoom(roomId.id, encodePasswd(dto.newPassword));
    //                          }
    //                         else
    //                         {
    //                             console.log('room is not PROTECTED')
    //                             return;
    //                         }
                            
    //                     }
    //                     else
    //                     {
    //                         console.log("cannot have the permission to change room Type.")
    //                     }   
    //                 }
    //                 else
    //                 {
    //                     console.log('room not found')
    //                     return;
    //                 }
                    
    //             } 
    //             else
    //             {
    //                 console.log('invalid jwt.');
    //             }
    //         }   
    //         catch (error) 
    //         {
               
    //             console.log(error)
    //         } 
    //     }


    //     // implement remove password of protected room





    //     /*
    //         * before ban user:
    //         - check if both user is exist
    //         - check room if exsit
    //         - check if both user in same room 
    //         - if is banned
    //         - check if current user is owner or admin
    //         - check if who want to be ban is not the owner

    //         - if finish duration remove the ban
    //     */





    //     @SubscribeMessage('ban-user')  // test  if is banned for limmited time and want to banned for ever
    //     @UsePipes(new ValidationPipe()) 
    //     async banFromRoom(@MessageBody() dto:BanFromRoom , @ConnectedSocket() socket: Socket) 
    //     {
    //         try 
    //         {
    //             const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);
    //             if (token) 
    //             {
    //                 const user  = await this.utils.verifyToken(token); // // if has error will catch it
    //                 const rtn = await this.utilsFunction(socket , user , dto.roomName , dto.bannedUserId , 2);
                    
    //                 if(rtn.error)
    //                 {
    //                     console.log(rtn.error)
    //                     return ;
    //                 }
                      
    //                 else
    //                 {
    //                     // if(rtn.usersType.usersType[0].userType !== 'USER' && rtn.usersType.usersType[1].userType !== 'OWNER') 
    //                     // { 
                            
    //                     //     if(dto.duration >= 3600000) // if it banned for limmited time can update the time of ban or set it first time
    //                     //     {
    //                     //         // in evry function like send message check if is banned for limmited time and if time is out
    //                     //         const banExpiresAt = new Date(Date.now() + dto.duration  ); // because date of now less then 1h
                               
    //                     //         // set exporation time
    //                     //         const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                                
    //                     //         const   bannedUser = await this.roomService.setBanExpirention(banExpiresAt, dto.bannedUserId , rtn.room.id );
                                
    //                     //         await this.roomService.removeUserFromRoom(rtn.room.id, rtn.usersType.usersType[1].userId);

                                

    //                     //         for(const userInRoom of usersInroom)
    //                     //         {
    //                     //             for (let i = 0; i < this.soketsId.length; i++) 
    //                     //             {
    //                     //                 if(this.soketsId[i].userId === userInRoom.userId)
    //                     //                 {
    //                     //                     this.server.to(this.soketsId[i].socketIds).emit("onBan",{ roomId: rtn.room , bannedUser , duration : dto.duration});
    //                     //                 } 
    //                     //             }
    //                     //         }

    //                     //         console.log('banned succufly')
                            
    //                     //     }
    //                     //     else if(dto.duration < 0)// banned for unlimeted time and remove her mesasges
    //                     //     {
    //                     //         const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                                
    //                     //         const   bannedUser =  await this.roomService.banUserForEver(dto.bannedUserId, rtn.room.id);

    //                     //         await this.roomService.removeUserFromRoom(rtn.room.id, rtn.usersType.usersType[1].userId);

                                
    //                     //         for(const userInRoom of usersInroom)
    //                     //         {
    //                     //             for (let i = 0; i < this.soketsId.length; i++) 
    //                     //             {
    //                     //                 if(this.soketsId[i].userId === userInRoom.userId)
    //                     //                 {
    //                     //                     this.server.to(this.soketsId[i].socketIds).emit("onBan",{ roomId: rtn.room , bannedUser , duration : dto.duration});
    //                     //                 } 
    //                     //             }
    //                     //         }

    //                     //         console.log('banned succufly')
                            
    //                     //     }
    //                     //     else
    //                     //     {
    //                     //         console.log('should ban from 1 hour to 3 days')
    //                     //     }
    //                     // }
    //                     // else
    //                     // {
    //                     //     console.log('dont have the permission to set an admin.');
    //                     //     return ;
    //                     // }
    //                 }  
    //             }
    //             else
    //             {
    //                 console.log('invalid jwt.');
    //             }
    //         } 
    //         catch (error) 
    //         {
    
    //             console.log(error)
    //         } 
    //     }





    //     @SubscribeMessage('leave-room')  // test  if is banned for limmited time and want to banned for ever

    //     @UsePipes(new ValidationPipe()) 
    //     async leaveRoom(@MessageBody() dto:LeaveRoom , @ConnectedSocket() socket: Socket) 
    //     {
    //         try 
    //         {
    //             const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);
    //             if (token) 
    //             {
    //                 const user  = await this.utils.verifyToken(token); // // if has error will catch it\

    //                 const rtn = await this.utilsFunction(socket , user , dto.roomName);
                    
    //                 if(rtn.error)
    //                 {
    //                     console.log(rtn.error)
    //                     return ;
    //                 }
                      
    //                 else
    //                 {
    //                     if(await this.roomService.doesRoomHaveUsers(rtn.room.id))
    //                     {
                            
    //                         const usersInroom = await this.utils.getUsersInRooms(rtn.room.id);
                            
    //                         const leavedUser : any = await this.roomService.removeUserFromRoom(rtn.room.id, user['sub']);
                            
    //                         if(rtn.usersType.usersType[0].userType === 'OWNER')
    //                         { 

    //                             const firstUser : any = await this.roomService.getFirstUserInRoom(rtn.room.id, 'ADMIN') // get first admin if found it
                                
    //                             let newOwner:any;

                                
    //                             if(!firstUser) // if no admin found
    //                             {
    //                                 const firstUser = await this.roomService.getFirstUserInRoom(rtn.room.id, 'USER')

    //                                 if(!firstUser)
    //                                 {
    //                                     await this.roomService.removeRoom(rtn.room.id)
    //                                     console.log(`${rtn.room.room_name} delted.`)
    //                                     return;
    //                                 }

    //                                 newOwner =  await this.roomService.setNewOwner(rtn.room.id, firstUser.userId);
                                    
                                  

    //                                 for(const userInRoom of usersInroom)
    //                                 {
    //                                     for (let i = 0; i < this.soketsId.length; i++) 
    //                                     {
    //                                         if(this.soketsId[i].userId === userInRoom.userId)
    //                                         {
    //                                             this.server.to(this.soketsId[i].socketIds).emit("onLeave",{ roomId: rtn.room , newOwner , leavedUser});
    //                                         } 
    //                                     }
    //                                 }
                                     
    //                             }
    //                             else
    //                             {
    //                                 newOwner =  await this.roomService.setNewOwner(rtn.room.id, firstUser.userId);

    //                                 for(const userInRoom of usersInroom)
    //                                 {
    //                                     for (let i = 0; i < this.soketsId.length; i++) 
    //                                     {
    //                                         if(this.soketsId[i].userId === userInRoom.userId)
    //                                         {
    //                                             this.server.to(this.soketsId[i].socketIds).emit("onLeave",{ roomId: rtn.room , newOwner , leavedUser});
    //                                         } 
    //                                     }
    //                                 }
    //                             }


    //                         }
    //                         else
    //                         {
    //                             for(const userInRoom of usersInroom)
    //                             {
    //                                 for (let i = 0; i < this.soketsId.length; i++) 
    //                                 {
    //                                     if(this.soketsId[i].userId === userInRoom.userId)
    //                                     {
    //                                         this.server.to(this.soketsId[i].socketIds).emit("onLeave",{ roomId: rtn.room , newOwner : null , leavedUser  });
    //                                     } 
    //                                 }
    //                             }

    //                         }      
    //                     }
    //                     else
    //                     {
    //                         await this.roomService.removeRoom(rtn.room.id)
    //                     }
    //                 }  
    //             }
    //             else
    //             {
    //                 console.log('invalid jwt.');
    //             }
    //         } 
    //         catch (error) 
    //         {
    
    //             console.log(error)
    //         } 
    //     }

    //     @SubscribeMessage('mute-user')  // test  if is banned for limmited time and want to banned for ever
    //     @UsePipes(new ValidationPipe()) 
    //     async mute(@MessageBody() dto:Mute , @ConnectedSocket() socket: Socket) 
    //     {
    //         try 
    //         {
    //             const token = this.utils.verifyJwtFromHeader(socket.handshake.headers.authorization);
                
    //             if (token) 
    //             {
    //                 const user  = await this.utils.verifyToken(token); // // if has error will catch it

    //                 const rtn = await this.utilsFunction(socket , user , dto.roomName , dto.mutedUserId);
                    
    //                 if(rtn.error)
    //                 {
    //                     console.log(rtn.error)
    //                     return ;
    //                 }
                      
    //                 if(rtn.usersType.usersType[0].userType !== 'USER' && rtn.usersType.usersType[1].userType !== 'OWNER') 
    //                 {
    //                     // set user as muted
    //                     if(dto.duration >= 3600000) // if it banned for limmited time can update the time of ban or set it first time
    //                     {
    //                         // in evry function like send message check if is banned for limmited time and if time is out
    //                         const banExpiresAt = new Date(Date.now() + dto.duration  ); // because date of now less then 1h
                            
    //                         // set exporation time
                                
    //                         await this.roomService.setMuteExpirention(banExpiresAt, dto.mutedUserId , rtn.room.id , 'MUTEDFORLIMITEDTIME' );
                            
                            
    //                         console.log('muted succufly')
                        
    //                     }
    //                     else if(dto.duration < 0)// banned for unlimeted time and remove her mesasges
    //                     {
                                
    //                         //   await this.roomService.banUserForEver(dto.bannedUserId, rtn.room.id);
    //                         await this.roomService.setMuteExpirention(null, dto.mutedUserId , rtn.room.id , 'MUTEDFOREVER' );

    //                         console.log('muted succufly')
                        
    //                     }
    //                     else
    //                     {
    //                         console.log('should mute from 1 hour to 3 days')
    //                     }
                        
    //                 }  
    //                 else
    //                 {
    //                     console.log('dont have the permission to set an admin.');
    //                 }
    //             }
    //             else
    //             {
    //                 console.log('invalid jwt.');
    //             }
    //         } 
    //         catch (error) 
    //         {
    
    //             console.log(error)
    //         } 
    //     }

